# -*- coding: utf-8 -*-
"""EDA .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xmwWJZYUtz0RkBY5_xm345O7eZFPlPa3
"""

#Importing necessary Libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

data=pd.read_csv('/content/sample_data/quant_data.csv')
data.head()

print(data['signal'].unique())

#Converting to float datatype
data['Fear_and_Greed_Index'] = data['Fear_and_Greed_Index'].astype(float)

signal_mapping = {'buy': 1, 'sell': -1, 'none': 0} # Mapping categorical variable into numerical
data['signal'] = data['signal'].map(signal_mapping)

data.head()

data.describe()
data.isnull().sum()

data['signal'].value_counts()

plt.figure(figsize=(12, 9))
plt.plot(data['datetime'], data['close'], color='blue')
plt.title('Price Chart with Buy/Sell signals')
plt.xlabel('Time')
plt.ylabel('Closing Price')

buy_signals = data[data['signal'] == 1]
sell_signals = data[data['signal'] == -1]
plt.scatter(buy_signals['datetime'], buy_signals['close'], color='green', marker='^', label='Buy Signal')
plt.scatter(sell_signals['datetime'], sell_signals['close'], color='red', marker='v', label='Sell Signal')

plt.legend()
plt.xticks(rotation=45)  # Rotate x-axis labels
plt.show()

"""Plotting EMAs along with buy/sell signals to identify potential trading opportunities."""

data['9_ema'] = data['close'].ewm(span=9, adjust=False).mean()
data['21_ema'] = data['close'].ewm(span=21, adjust=False).mean()
data['50_ema'] = data['close'].ewm(span=50, adjust=False).mean()

# Plot the stock price and EMAs
plt.figure(figsize=(12, 6))
plt.plot(data['datetime'], data['close'], label='Close Price', color='blue')
plt.plot(data['datetime'], data['9_ema'], label='9 EMA', color='green')
plt.plot(data['datetime'], data['21_ema'], label='21 EMA', color='orange')
plt.plot(data['datetime'], data['50_ema'], label='50 EMA', color='red')

buy_signals = data[data['signal'] == 1]
sell_signals = data[data['signal'] == -1]
plt.scatter(buy_signals['datetime'], buy_signals['close'], color='green', marker='^', label='Buy Signal')
plt.scatter(sell_signals['datetime'], sell_signals['close'], color='red', marker='v', label='Sell Signal')

plt.title('Stock Price with EMA')
plt.xlabel('Date')
plt.ylabel('Price')
plt.legend()
plt.xticks(rotation=45)  # Rotating x-axis labels
plt.tight_layout()
plt.show()

"""# Data Pre-Processing

CORRELATION MATRIX :generated the correlation matrix.
"""

data = data.drop('datetime', axis=1)
data = pd.DataFrame(data.iloc[:,:])
correlation_matrix = data.corr()
correlation_matrix = data.corr()
plt.figure(figsize=(10, 8))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f")
plt.title("Correlation Matrix")
plt.show()

"""Handling Outliers"""

columns_to_handle_outliers = ['open', 'high', 'low', 'close', 'volume', 'reserve', 'funding_rates',
                              'mvrv', 'nrpl', 'nupl', 'stock_to_flow_reversion', 'sth_sopr', 'RSI', '9_ema', '21_ema', '50_ema', '200_ema']

#OUTLIER VISUALIZATION
plt.figure(figsize=(15, 10))
for i, column in enumerate(columns_to_handle_outliers, 1):
    plt.subplot(5, 4, i)
    sns.stripplot(x=data[column])
    plt.title(column)
    plt.xlabel('')
    plt.ylabel('Value')

plt.tight_layout()
plt.show()

for i in columns_to_handle_outliers:
    Q1 = data[i].quantile(0.25)
    Q3 = data[i].quantile(0.75)
    IQR = Q3 - Q1

    lower_bound = Q1 - 1.5 * IQR
    upper_bound = Q3 + 1.5 * IQR

    outliers = (data[i] < lower_bound) | (data[i] > upper_bound)
    data.loc[outliers, i] = None

processed_data= data.dropna()

"""# Developing a ML Model

K-Nearest Neighbors (KNN)
"""

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score

x = processed_data.drop(columns=['signal'])
y = processed_data['signal']

x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=42)

knn_classifier = KNeighborsClassifier()
knn_classifier.fit(x_train, y_train)

y_pred = knn_classifier.predict(x_test)
accuracy = accuracy_score(y_test, y_pred)
print("Accuracy:", round(accuracy*100,2),'%')

"""STACKING XGB,LGBM AND CATBOOSTER"""

pip install catboost

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.ensemble import StackingClassifier
from sklearn.linear_model import LogisticRegression
from xgboost import XGBClassifier
from lightgbm import LGBMClassifier
from catboost import CatBoostClassifier
from sklearn.metrics import accuracy_score

x = data.drop(columns=['signal'])
y = data['signal']



xgb_model = XGBClassifier()
lgbm_model = LGBMClassifier()
catboost_model = CatBoostClassifier()


meta_learner = LogisticRegression() #Base Model


stacking_classifier = StackingClassifier(estimators=[('xgb', xgb_model), ('lgbm', lgbm_model), ('catboost', catboost_model)],final_estimator=meta_learner,cv=5)

stacking_classifier.fit(x_train, y_train)

# Predicting target labels for test data
y_pred_stacking = stacking_classifier.predict(x_test)

# Calculating accuracy
accuracy_stacking = accuracy_score(y_test, y_pred_stacking)
print("Stacking Classifier Accuracy:", accuracy_stacking*100)

